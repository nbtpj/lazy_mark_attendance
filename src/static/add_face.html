<!DOCTYPE HTML>
<html>
<head>
    <title>Full-Screen Face Detection with Capture & Save</title>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/human@3.3.5/dist/human.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #e0e7ff, #c3dafe);
            overflow: hidden;
        }

        .video-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        #video {
            display: block;
            max-width: 100vw;
            max-height: 100vh;
        }

        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            padding: 20px 30px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: 500;
            z-index: 20;
        }

        .spinner {
            border: 5px solid #ffffff;
            border-top: 5px solid #3b82f6;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 0.8s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .error {
            background: rgba(220, 38, 38, 0.9);
            padding: 15px;
            border-radius: 8px;
            max-width: 80%;
            text-align: center;
        }

        #camera-select {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px;
            font-size: 1em;
            border-radius: 5px;
            border: 1px solid #ccc;
            background: #fff;
            z-index: 10;
            max-width: 90%;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            border-radius: 8px;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 15;
            max-width: 90vw;
        }

        #identity-input {
            padding: 8px;
            font-size: 1em;
            border-radius: 5px;
            border: 1px solid #ccc;
            flex-grow: 1;
        }

        #capture-btn, #save-btn, #cancel-btn {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            user-select: none;
        }

        #capture-btn {
            background-color: #3b82f6;
            color: white;
        }

        #save-btn {
            background-color: #16a34a;
            color: white;
        }

        #cancel-btn {
            background-color: #ef4444;
            color: white;
        }

        /* Hide save controls initially */
        #save-controls {
            display: none;
            width: 100%;
            gap: 10px;
        }
    </style>
</head>
<body>
<select id="camera-select" onchange="changeCamera()">
    <option value="">Select a camera</option>
</select>
<div class="video-container">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>
    <div id="loading">
        <div class="spinner"></div>
        <p>Loading...</p>
    </div>
</div>

<div id="controls">
    <button id="capture-btn">Capture</button>

    <div id="save-controls">
        <input type="text" id="identity-input" placeholder="Enter identity" />
        <button id="save-btn">Save</button>
        <button id="cancel-btn">Cancel</button>
    </div>
</div>

<script>
    const human = new Human.Human({
        backend: 'webgl', // fallback to wasm if needed
        modelBasePath: 'https://cdn.jsdelivr.net/npm/@vladmandic/human@3.3.5/models/',
        face: {
            enabled: true,
            detector: {rotation: true, return: true, mask: false},
            description: {enabled: true},
            iris: {enabled: true},
            emotion: {enabled: false},
            antispoof: {enabled: true},
            liveness: {enabled: true},
        },
        body: {enabled: false},
        hand: {enabled: false},
        object: {enabled: false},
        gesture: {enabled: true},
    });

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const loading = document.getElementById('loading');
    const cameraSelect = document.getElementById('camera-select');

    const captureBtn = document.getElementById('capture-btn');
    const saveControls = document.getElementById('save-controls');
    const identityInput = document.getElementById('identity-input');
    const saveBtn = document.getElementById('save-btn');
    const cancelBtn = document.getElementById('cancel-btn');

    let currentStream;
    let paused = false;
    let lastDetectedFace = null; // store face box from last capture
    let bufferCanvas, bufferCtx;

    async function listCameras() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        cameraSelect.innerHTML = '';
        if (videoDevices.length === 0) {
            const option = document.createElement('option');
            option.text = 'No cameras found';
            cameraSelect.appendChild(option);
            return;
        }
        videoDevices.forEach((device, i) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${i + 1}`;
            cameraSelect.appendChild(option);
        });
    }

    async function setupWebcam(deviceId) {
        try {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            const constraints = deviceId ? {video: {deviceId: {exact: deviceId}}} : {video: true};
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            currentStream = stream;
            video.srcObject = stream;
            await new Promise(resolve => video.onloadedmetadata = resolve);
            await video.play();
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            bufferCanvas = document.createElement('canvas');
            bufferCanvas.width = video.videoWidth;
            bufferCanvas.height = video.videoHeight;
            bufferCtx = bufferCanvas.getContext('2d');
            return true;
        } catch (err) {
            loading.innerHTML = `<p class="error">Error: Could not access webcam. ${err.message}. Please allow camera access and try again.</p>`;
            return false;
        }
    }

    async function changeCamera() {
        const deviceId = cameraSelect.value;
        if (deviceId) {
            loading.style.display = 'flex';
            loading.innerHTML = '<div class="spinner"></div><p>Switching camera...</p>';
            const success = await setupWebcam(deviceId);
            if (success) {
                loading.style.display = 'none';
            }
        }
    }

    // We don't do continuous detect loop anymore. Instead, detect on capture.
    async function detectOnce() {
        bufferCtx.drawImage(video, 0, 0, bufferCanvas.width, bufferCanvas.height);

        try {
            const result = await human.detect(bufferCanvas);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (result.face && result.face.length > 0) {
                // Pick the first face with good live & real scores
                const face = result.face.find(f => f.live >= 0.0 && f.real >= 0.0) || result.face[0];
                lastDetectedFace = face;

                const [x, y, w, h] = face.box;

                // Draw bounding box
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeRect(x, y, w, h);

                return true;
            } else {
                lastDetectedFace = null;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                alert('No face detected. Please try again.');
                return false;
            }
        } catch (err) {
            console.error('Detection error:', err);
            alert('Error during detection: ' + err.message);
            return false;
        }
    }

    // Capture button click handler
    captureBtn.addEventListener('click', async () => {
        if (paused) return; // ignore if already paused

        // Pause the video
        video.pause();
        paused = true;

        const detected = await detectOnce();
        if (detected) {
            // Show save controls
            saveControls.style.display = 'flex';
            captureBtn.style.display = 'none';
            identityInput.value = '';
            identityInput.focus();
        } else {
            // Resume if no face detected
            video.play();
            paused = false;
        }
    });

    // Save button click handler
    saveBtn.addEventListener('click', async () => {
        const identity = identityInput.value.trim();
        if (!identity) {
            alert('Please enter an identity.');
            identityInput.focus();
            return;
        }
        if (!lastDetectedFace) {
            alert('No detected face to save.');
            return;
        }

        const [x, y, w, h] = lastDetectedFace.box;

        // Crop face image from bufferCanvas
        const faceCanvas = document.createElement('canvas');
        faceCanvas.width = w;
        faceCanvas.height = h;
        const faceCtx = faceCanvas.getContext('2d');
        faceCtx.drawImage(bufferCanvas, x, y, w, h, 0, 0, w, h);

        // Convert to blob and send
        faceCanvas.toBlob(async (blob) => {
            try {
                const formData = new FormData();
                formData.append('face_image', blob, 'face.jpg');
                formData.append('identity', identity);

                const response = await fetch('/upload_face_ta', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`Server responded with status ${response.status}`);
                }

                alert('Face and identity saved successfully!');
            } catch (err) {
                console.error('Upload failed:', err);
                alert('Failed to save data: ' + err.message);
            } finally {
                resumeVideo();
            }
        }, 'image/jpeg', 0.9);
    });

    // Cancel button click handler
    cancelBtn.addEventListener('click', () => {
        resumeVideo();
    });

    function resumeVideo() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        saveControls.style.display = 'none';
        captureBtn.style.display = 'inline-block';
        identityInput.value = '';
        video.play();
        paused = false;
        lastDetectedFace = null;
    }

    async function main() {
        try {
            loading.innerHTML = '<div class="spinner"></div><p>Loading models...</p>';
            await human.load();
            loading.innerHTML = '<div class="spinner"></div><p>Requesting webcam access...</p>';
            const success = await setupWebcam();
            if (!success) {
                return;
            }
            await listCameras();
            loading.style.display = 'none';
        } catch (err) {
            loading.innerHTML = `<p class="error">Error initializing: ${err.message}</p>`;
        }
    }

    main();
</script>
</body>
</html>
